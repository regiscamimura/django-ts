import re
import sys
from argparse import ArgumentParser
from collections.abc import Iterable, Sequence
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING, Any, NamedTuple, Protocol, TypeAlias, final

if TYPE_CHECKING:
    from django.apps.config import AppConfig

from django.apps import apps
from django.conf import settings
from django.core.management import BaseCommand

__all__ = [
    "Command",
    "ConstantValue",
    "Constants",
    "EnumMember",
    "Enums",
    "HasMeta",
    "ModelExtractor",
    "ModelTypes",
    "TypeScriptWriter",
]

ConstantValue: TypeAlias = str | int | float
Constants: TypeAlias = dict[str, ConstantValue]


class EnumMember(NamedTuple):
    name: str
    value: ConstantValue
    label: str


Enums: TypeAlias = dict[str, list[EnumMember]]


class HasMeta(Protocol):
    _meta: Any
    __name__: str


@final
@dataclass(slots=True, frozen=True)
class ModelTypes:
    model_name: str
    constants: Constants = field(default_factory=dict)
    enums: Enums = field(default_factory=dict)

    @property
    def has_content(self) -> bool:
        return bool(self.constants or self.enums)


@final
class ModelExtractor:
    __slots__ = ()

    def extract(self, model: HasMeta) -> ModelTypes:
        model_name = getattr(model._meta, "object_name", None) or model.__name__
        constants: Constants = {}
        value_to_name: dict[ConstantValue, str] = {}
        choices_tuples: list[tuple[str, Sequence[tuple[ConstantValue, str]]]] = []

        for name in dir(model):
            if name.startswith("_"):
                continue

            try:
                value = getattr(model, name)
            except AttributeError:
                continue

            if self._is_constant(name, value):
                constants[name] = value
                value_to_name[value] = name
            elif self._is_choices_tuple(value):
                choices_tuples.append((name, value))

        enums = self._build_enums(choices_tuples, value_to_name)
        return ModelTypes(model_name=model_name, constants=constants, enums=enums)

    def _build_enums(
        self,
        choices_tuples: list[tuple[str, Sequence[tuple[ConstantValue, str]]]],
        value_to_name: dict[ConstantValue, str],
    ) -> Enums:
        enums: Enums = {}
        for name, choices in choices_tuples:
            enum_name = self._to_enum_name(name)
            members = [
                EnumMember(
                    name=value_to_name.get(val) or self._value_to_name(val),
                    value=val,
                    label=label,
                )
                for val, label in choices
            ]
            if members:
                enums[enum_name] = members
        return enums

    @staticmethod
    def _is_constant(name: str, value: object) -> bool:
        return isinstance(value, str | int | float) and name.isupper() and "_" in name

    @staticmethod
    def _is_choices_tuple(value: object) -> bool:
        if not isinstance(value, list | tuple) or not value:
            return False
        first = value[0]
        return (
            isinstance(first, list | tuple)
            and len(first) == 2
            and isinstance(first[1], str)
        )

    @staticmethod
    def _to_enum_name(name: str) -> str:
        name = re.sub(r"_TYPES$|_CHOICES$", "", name)
        parts = name.lower().split("_")
        return "".join(word.capitalize() for word in parts) + "Enum"

    @staticmethod
    def _value_to_name(value: ConstantValue) -> str:
        if isinstance(value, str):
            return value.upper().replace("-", "_").replace(" ", "_")
        return f"VALUE_{value}"


@final
class TypeScriptWriter:
    __slots__ = ("output_dir", "dry_run", "changed")

    def __init__(self, output_dir: Path, *, dry_run: bool = False) -> None:
        self.output_dir = output_dir
        self.dry_run = dry_run
        self.changed: list[str] = []

    def write_all(self, models: Iterable[ModelTypes]) -> list[str]:
        models = list(models)
        self._write_constants(models)
        self._write_enums(models)
        self._write_index()
        return self.changed

    def _write_constants(self, models: Sequence[ModelTypes]) -> None:
        lines = ["// Auto-generated by Django - do not edit manually", ""]

        for model in sorted(models, key=lambda m: m.model_name):
            if not model.constants:
                continue

            lines.append(f"export const {model.model_name} = {{")
            for name in sorted(model.constants.keys()):
                value = model.constants[name]
                formatted = f'"{value}"' if isinstance(value, str) else value
                lines.append(f"  {name}: {formatted},")
            lines.append("} as const")
            lines.append("")

        self._write_file("constants.ts", "\n".join(lines))

    def _write_enums(self, models: Sequence[ModelTypes]) -> None:
        lines = ["// Auto-generated by Django - do not edit manually", ""]

        for model in sorted(models, key=lambda m: m.model_name):
            for enum_name, members in model.enums.items():
                lines.append(f"export enum {model.model_name}{enum_name} {{")
                for member in members:
                    formatted = (
                        f'"{member.value}"'
                        if isinstance(member.value, str)
                        else member.value
                    )
                    lines.append(f"  {member.name} = {formatted}, // {member.label}")
                lines.append("}")
                lines.append("")

        self._write_file("enums.ts", "\n".join(lines))

    def _write_index(self) -> None:
        content = "\n".join(
            [
                "// Auto-generated by Django - do not edit manually",
                "",
                'export * from "./constants";',
                'export * from "./enums";',
                "",
            ]
        )
        self._write_file("index.ts", content)

    def _write_file(self, filename: str, content: str) -> None:
        self.output_dir.mkdir(parents=True, exist_ok=True)
        path = self.output_dir / filename

        if path.exists() and path.read_text() == content:
            return

        self.changed.append(str(path))

        if not self.dry_run:
            path.write_text(content)


class Command(BaseCommand):
    help = "Generates TypeScript constants and enums from Django model constants."

    def add_arguments(self, parser: ArgumentParser) -> None:
        parser.add_argument(
            "--output",
            type=str,
            default="./frontend/constants",
            help="Output directory for generated TypeScript files",
        )
        parser.add_argument(
            "--check",
            action="store_true",
            help="Check if files are up to date without writing",
        )
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help="Show what would be generated without writing files",
        )

    def handle(self, *_, **options) -> None:
        output_dir = Path(options["output"])
        check_mode: bool = options["check"]
        dry_run: bool = options["dry_run"] or check_mode

        extractor = ModelExtractor()
        models = [
            result
            for app_config in apps.get_app_configs()
            if self._is_project_app(app_config)
            for model in app_config.get_models()
            if (result := extractor.extract(model)).has_content
        ]

        writer = TypeScriptWriter(output_dir, dry_run=dry_run)
        changed = writer.write_all(models)

        self._report_results(changed, check_mode, options["dry_run"])

    def _report_results(
        self, changed: list[str], check_mode: bool, dry_run: bool
    ) -> None:
        match (bool(changed), check_mode, dry_run):
            case (False, _, _):
                self.stdout.write(self.style.SUCCESS("All files up to date"))
            case (True, True, _):
                self.stdout.write(
                    self.style.ERROR(f"Files out of date: {', '.join(changed)}")
                )
                sys.exit(1)
            case (True, _, True):
                self.stdout.write(
                    self.style.WARNING(f"Would update: {', '.join(changed)}")
                )
            case (True, _, _):
                self.stdout.write(self.style.SUCCESS(f"Updated: {', '.join(changed)}"))

    def _is_project_app(self, app_config: "AppConfig") -> bool:
        base_dir = getattr(settings, "BASE_DIR", None)
        if base_dir is None:
            return True

        try:
            Path(app_config.path).relative_to(base_dir)
            return True
        except ValueError:
            return False
